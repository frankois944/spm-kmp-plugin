{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Swift Package Manager for Kotlin Multiplatform","text":"<p>The Swift Package Manager for Kotlin Multiplatform Plugin, aka <code>spmForKmp</code> Gradle Plugin, is a tool designed to simplify integrating Swift Package Manager (SPM) dependencies into Kotlin Multiplatform (KMP) projects and calling the native API.</p> <p>It allows you to (almost) effortlessly configure and use Swift packages in your Kotlin projects targeting Apple platforms, such as iOS.</p> <p>Please Be Aware</p> <p>Pure Swift packages can't be exported to Kotlin; creating a bridge with this plugin is a solution to bypass this issue.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create a Swift&lt;-&gt;Kotlin bridge: Use your own Swift code for functionality that can't be done in Kotlin.</li> <li>Import Swift-compatible code to Kotlin: Enable SPM dependencies and your own Swift code to be exposed directly in your Kotlin code (if compatible).</li> </ul>"},{"location":"#feedback","title":"Feedback","text":"<p>This project greatly needs feedback, feature requests, and information about the edge case for progressing; let's talk.</p>"},{"location":"#full-example","title":"Full example","text":"<p>A full example is available for people wanted to see the usage.</p>"},{"location":"bridge/","title":"Basic Configuration","text":""},{"location":"bridge/#gradle","title":"Gradle","text":"<p>The following configuration is a simple bridge between Kotlin and Swift.</p> build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n    }\n}\n</code></pre> <p>When syncing the project, the plugin creates a folder at <code>src/swift/[cinteropname]</code>.</p> <p>The content of this folder is your bridge between Swift and Kotlin, it can contain only Swift source files or no file.</p>"},{"location":"bridge/#example","title":"Example","text":"<p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p> src/swift/[cinteropname]/mySwiftFile.swift<pre><code>@objcMembers public class MySwiftBridge: NSObject {\n    public func exportedMethod() -&gt; String {\n        return \"value\"\n    }\n}\n</code></pre> iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import [cinteropname].MySwiftBridge\n\nval contentFromSwift = MySwiftBridge().exportedMethod()\n</code></pre>"},{"location":"bridgeWithDependencies/","title":"Using External Dependencies","text":"<p>On completion with the basic configuration, it's possible to use external dependency with your bridge.</p> <p>The Plug-in reproduces the CocoaPods plugin behavior with the same kind of issues about third-party dependency but less intrusively.</p> <p>Note</p> <p>If your package doesn't work with the plugin, please create an issue.</p>"},{"location":"bridgeWithDependencies/#gradle","title":"Gradle","text":"<p>The following configuration imports the package CryptoSwift which is a pure Swift library, that can't be used directly in Kotlin. build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n        dependency(\n            SwiftDependency.Package.Remote.Version(\n                url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n                products = {\n                    add(\"CryptoSwift\")\n                },\n                version = \"1.8.4\",\n            )\n        )\n    }\n}\n</code></pre></p> <p>Warning</p> <p>A local swift package is being generated during the build and this message diplayed <pre><code>Spm4Kmp: A local Swift package has been generated at\n/path/to/the/local/package\nPlease add it to your xcode project as a local package dependency.\n</code></pre> Add the folder to your Xcode project as a Local package, that's all.</p> <p>Note : When updating your configuration, reset the package cache to apply the modification.</p>"},{"location":"bridgeWithDependencies/#example","title":"Example","text":"<p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p> src/swift/[cinteropname]/mySwiftFile.swift<pre><code>import Foundation\nimport CryptoSwift\n\n@objcMembers public class MySwiftBridge: NSObject {\n    public func toMD5(value: String) -&gt; String {\n        return value.md5()\n    }\n}\n</code></pre> iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import [cinteropname].MySwiftBridge\n\nval contentFromSwift = MySwiftBridge().toMD5(value = \"someString\")\n</code></pre>"},{"location":"bridgeWithDependencies/#supported-dependency-sources","title":"Supported Dependency Sources","text":"<p>The plugin supports the following configurations :</p> VersionCommitBranchLocalLocal BinaryRemote Binary <pre><code>SwiftDependency.Package.Remote.Version(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    version = \"1.8.4\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n)\n</code></pre> <pre><code>SwiftDependency.Package.Remote.Commit(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    revision = \"729e01bc9b9dab466ac85f21fb9ee2bc1c61b258\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n)\n</code></pre> <pre><code>SwiftDependency.Package.Remote.Branch(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    branch = \"main\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n),\n</code></pre> <pre><code>SwiftDependency.Package.Local(\n    path = \"Absolute path to the local package folder\",\n    packageName = \"LocalSourceDummyFramework\",\n    products = {\n        add(\"LocalSourceDummyFramework\")\n    },\n),\n</code></pre> <pre><code>SwiftDependency.Binary.Local(\n    path = \"/path/to/LocalFramework.xcframework\"\n    packageName = \"LocalFramework\"\n),\n</code></pre> <pre><code>SwiftDependency.Binary.Remote(\n    url = URI(\"https://.../RemoteBinaryFramework.xcframework.zip\"),\n    checksum = \"[checksum]\",\n    packageName = \"RemoteBinaryFramework\",\n)\n</code></pre> <p>SwiftDependency reference</p>"},{"location":"bridgeWithDependencies/#xcframework","title":"XcFramework","text":"<p>The xcFramework are used for Local/Remote Binary, learn more.</p> <p>An example is available.</p>"},{"location":"distribution/","title":"Distribute Kotlin Library","text":""},{"location":"distribution/#release-a-library-using-the-plugin","title":"Release a library using the plugin","text":"<p>We can distribute to other users a Kotlin library using native or third-party dependency, some requirements are necessary for Apple targets.</p>"},{"location":"distribution/#requirement","title":"Requirement","text":"<p>The user must :</p> <ul> <li>add the same native dependency used by the Kotlin library to his Xcode project.</li> <li>use the same version as the library use.</li> </ul> <p>It will fix issues with linking, missing resources, App Store compliance, and more.</p> <p>Also, the user doesn't have access to the Kotlin library source code, which is great!</p>"},{"location":"distribution/#example","title":"Example","text":"<p>A Compose Multiplatform Component library using a native video player.</p> commonMain/kotlin/KmpPlayer.kt<pre><code>@Composable\npublic expect fun KmpPlayer(modifier: Modifier = Modifier, url: String)\n</code></pre>"},{"location":"distribution/#android","title":"Android","text":"<p>For Android, it uses Exoplyer.</p>"},{"location":"distribution/#gradle","title":"Gradle","text":"library/build.gradle.kts<pre><code>androidMain.dependencies {\n    implementation(libs.media3.exoplayer)\n    implementation(libs.media3.exoplayer.dash)\n    implementation(libs.media3.ui)\n}\n</code></pre>"},{"location":"distribution/#androidmain","title":"AndroidMain","text":"androidMain/kotlin/KmpPlayer.kt<pre><code>@Composable\npublic actual fun KmpPlayer(modifier: Modifier, url: String) {\n\n    val context = LocalContext.current\n\n    // Initialize ExoPlayer\n    val exoPlayer = ExoPlayer.Builder(context).build()\n\n    val mediaSource = remember(url) {\n        MediaItem.fromUri(url)\n    }\n\n\n    LaunchedEffect(url) {\n        exoPlayer.setMediaItem(mediaSource)\n        exoPlayer.prepare()\n    }\n\n    // Manage lifecycle events\n    DisposableEffect(Unit) {\n        onDispose {\n            exoPlayer.release()\n        }\n    }\n\n    AndroidView(\n        factory = { ctx -&gt;\n            PlayerView(ctx).apply {\n                player = exoPlayer\n            }\n        },\n        modifier = modifier\n    )\n}\n</code></pre>"},{"location":"distribution/#ios","title":"iOS","text":"<p>For iOS, it uses KSPlayer, it's a pure Swift library.</p>"},{"location":"distribution/#gradle_1","title":"Gradle","text":"library/build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"appleDeps\") {\n        minIos = \"13.0\"\n        minMacos = \"10.15\"\n        minTvos = \"13.0\"\n        minWatchos = \"2.0\"\n        dependency(\n            SwiftDependency.Package.Remote.Branch(\n                url = URI(\"https://github.com/kingslay/KSPlayer\"),\n                products = {\n                    add(\"KSPlayer\")\n                },\n                branch = \"main\"\n            ),\n        )\n    }\n}\n</code></pre>"},{"location":"distribution/#appledeps","title":"AppleDeps","text":"src/swift/appleDeps/MEPlayerController.swift<pre><code>import Foundation\nimport KSPlayer\n\n@objcMembers public class MEPlayerController: NSObject {\n     private let player = IOSVideoPlayerView()\n\n    override init() {\n       super.init()\n       KSOptions.secondPlayerType = KSMEPlayer.self\n       player.delegate = self\n       player.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n       player.contentMode = .scaleAspectFill\n    }\n\n    public func setMediaItem(videoUrl: URL) {\n       player.set(\n          url: videoUrl,\n          options: KSOptions()\n      )\n    }\n\n    public var playerView: NSObject {\n       player\n    }\n\n    public func releasePlayer() {\n       player.resetPlayer()\n       player.removeFromSuperview()\n    }\n}\n</code></pre>"},{"location":"distribution/#iosmain","title":"iOSMain","text":"iosMain/kotlin/KmpPlayer.kt<pre><code>import appleDeps.MEPlayerController\n\n@Composable\npublic actual fun KmpPlayer(modifier: Modifier, url: String) {\n\n    val playerController = MEPlayerController()\n\n    val mediaSource = remember(url) {\n        NSURL.URLWithString(url)\n    }\n\n    LaunchedEffect(url) {\n        if (mediaSource == null) {\n            throw Exception(\"Bad input URL\")\n        }\n        playerController.setMediaItemWithVideoUrl(videoUrl = mediaSource)\n    }\n\n    DisposableEffect(Unit) {\n        onDispose {\n            playerController.releasePlayer()\n        }\n    }\n\n    UIKitView(\n        factory = {\n            playerController.playerView() as UIView\n        },\n        modifier = modifier,\n        update = {\n        }\n    )\n}\n</code></pre>"},{"location":"distribution/#requirement_1","title":"Requirement","text":"<p>The setup guide of your library must contain the rule that KSPlayer package must be added to his Xcode project with the explicit version.</p>"},{"location":"distribution/#sample","title":"Sample","text":"<p>The sample is available.</p> <ul> <li>Run the command <code>./gradlew publishToMavenLocal --no-configuration-cache</code> on the repository root.</li> <li>Open the project <code>sampleApp</code> and test the application</li> </ul>"},{"location":"exportingDependencies/","title":"Export Dependencies To Kotlin","text":"<p>On completion with using external dependencies, it's possible to export them to Kotlin, if they are compatible.</p> <p>Exported dependency can be used inside the bridge and the Kotlin app.</p> <p>Note</p> <p>If your package doesn't work with the plugin, please create an issue.</p>"},{"location":"exportingDependencies/#gradle","title":"Gradle","text":"<p>The following configuration export to Kotlin the package FirebaseAnalytics which is a ObjC library.</p> <p>You can try to export a pure Swift library, but only basic ObjC will be available.</p> build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n        dependency(\n            SwiftDependency.Package.Remote.Version(\n                url = URI(\"https://github.com/firebase/firebase-ios-sdk.git\"),\n                products = {\n                    add(\"FirebaseAnalytics\", exportToKotlin = true), // exported\n                    add(\"FirebaseCore\") // non-exported\n                },\n                version = \"11.8.0\",\n            )\n        )\n    }\n}\n</code></pre> <p>Warning</p> <p>A local swift package is being generated during the build and this message diplayed <pre><code>Spm4Kmp: A local Swift package has been generated at\n/path/to/the/local/package\nPlease add it to your xcode project as a local package dependency.\n</code></pre> Add the folder to your Xcode project as a Local package, that's all.</p> <p>Note : When updating your configuration, reset the package cache to apply the modification.</p>"},{"location":"exportingDependencies/#example","title":"Example","text":"iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import FirebaseAnalytics.FIRConsentStatusGranted\n\n@ExperimentalForeignApi\nval consentStatusGranted = FIRConsentStatusGranted\n</code></pre> <p>Note</p> <p>The bridge can remain empty as we don't need it; we only want to use the exported product.</p>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT) Copyright (c) 2025 Fran\u00e7ois Dabonot</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"multiTarget/","title":"Multi Target Configuration","text":""},{"location":"multiTarget/#configuration-by-target","title":"Configuration by target","text":"<p>You can set a different configuration for each target you manage.</p> build.gradle.kts<pre><code>listOf(\n    iosX64(),\n    iosSimulatorArm64(),\n).forEach {\n    it.compilations {\n        val main by getting {\n            cinterops.create(\"nativeIosShared\") // a config for iOS\n        }\n    }\n}\n\nlistOf(\n    macosArm64(),\n).forEach {\n    it.compilations {\n        val main by getting {\n            cinterops.create(\"nativeMacosShared\") // a config for macos\n        }\n    }\n}\n\nswiftPackageConfig {\n    create(\"nativeIosShared\") {\n        // your embedded swift is inside the folder src/swift/nativeIosShared\n        // your config for iOS\n    }\n    create(\"nativeMacosShared\") {\n        // your embedded swift is inside the folder src/swift/nativeMacosShared\n        // your config for macOS\n    }\n}\n</code></pre>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#requirement","title":"Requirement","text":"<ul> <li>Macos With Xcode 16 and later</li> <li>Kotlin : 2.1.0 and later</li> <li>Gradle : 8.12 recommended</li> </ul>"},{"location":"setup/#plugins","title":"Plugins","text":"build.gradle.kts<pre><code>plugins {\n    id(\"org.jetbrains.kotlin.multiplatform\")\n    id(\"io.github.frankois944.spmForKmp\") version \"[version]\"\n}\n</code></pre>"},{"location":"setup/#gradle-properties","title":"Gradle Properties","text":"gradle.properties<pre><code>kotlin.mpp.enableCInteropCommonization=true\n</code></pre>"},{"location":"setup/#initial-configuration","title":"Initial configuration","text":"build.gradle.kts<pre><code>kotlin {\n    listOf(\n        iosArm64(),\n        iosSimulatorArm64()\n        // and more Apple targets...\n    ).forEach {\n        it.compilations {\n            val main by getting {\n                // Choose the cinterop name\n                cinterops.create(\"[cinteropName]\")\n            }\n        }\n    }\n}\n</code></pre> <p>swiftPackageConfig reference build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") { // must match with cinterops.create name\n    }\n}\n</code></pre></p>"},{"location":"references/swiftDependency/","title":"SwiftDependency","text":"<p>Work in progress</p>"},{"location":"references/swiftPackageConfig/","title":"SwiftPackageConfig","text":""},{"location":"references/swiftPackageConfig/#custompackagesourcepath","title":"customPackageSourcePath","text":"<pre><code>/**\n* Specifies the custom source path for the Swift package in the Kotlin Multiplatform project.\n*\n* By default, this path is set to the `src/swift` directory within the project's root directory.\n* This property allows defining a different directory for the Swift package source files,\n* enabling customized project structure organization.\n*/\npublic var customPackageSourcePath: String = Path(project.projectDir.path, \"src\", \"swift\").pathString\n</code></pre>"},{"location":"references/swiftPackageConfig/#minios","title":"minIos","text":"<pre><code>/**\n * Specifies the minimum iOS platform version required for the Swift package integration.\n *\n * This property determines the deployment target for the iOS platform when building the Swift package\n * within the Kotlin Multiplatform project. Modifying this value adjusts the generated build configuration\n * and compatibility of the resulting package with iOS devices and emulators.\n *\n * Default value: [DEFAULT_MIN_IOS_VERSION]\n */\npublic var minIos: String = DEFAULT_MIN_IOS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#minmacos","title":"minMacos","text":"<pre><code>/**\n * Specifies the minimum supported macOS version for the Swift Package Manager (SPM) integration.\n *\n * This property defines the macOS version targeted by the Swift package and its dependencies.\n * Used during the generation of SPM manifests and the compilation of Swift packages to ensure compatibility\n * with the specified macOS version.\n *\n * Default value: [DEFAULT_MIN_MAC_OS_VERSION]\n */\npublic var minMacos: String = DEFAULT_MIN_MAC_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#mintvos","title":"minTvos","text":"<pre><code>/**\n * Specifies the minimum required version of tvOS for the Swift package definition.\n *\n * This property is used to configure the minimum tvOS version that the Swift package\n * dependencies and targets must support.\n *\n * Default value: [DEFAULT_MIN_TV_OS_VERSION]\n */\npublic var minTvos: String = DEFAULT_MIN_TV_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#minwatchos","title":"minWatchos","text":"<pre><code>/**\n * Minimum watchOS version required for the Swift package.\n *\n * This variable is used to specify the minimum version of watchOS that a Swift package targets\n * when building or running tasks involving watchOS-specific code. It ensures compatibility\n * with the defined platform version during build processes or runtime configurations.\n *\n * Default value: [DEFAULT_MIN_WATCH_OS_VERSION]\n */\npublic var minWatchos: String = DEFAULT_MIN_WATCH_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#toolsversion","title":"toolsVersion","text":"<pre><code>/**\n * Specifies the version of Swift tools that will be utilized.\n * This version determines the compatibility and features available for the Swift Package Manager.\n *\n * The `toolsVersion` value impacts the structure of the `Package.swift` manifest file and\n * the behavior of the Swift package dependencies during resolution and compilation.\n *\n * Default value: [DEFAULT_TOOL_VERSION]\n */\npublic var toolsVersion: String = DEFAULT_TOOL_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#debug","title":"debug","text":"<pre><code>/**\n * Indicates whether the Swift package is built in debug mode.\n *\n * If set to `true`, the package is being built with debug configuration. This can be useful for\n * testing or development purposes where debug symbols and additional information are required.\n *\n * Note: release build are faster\n *\n * Default value: `false`\n */\npublic var debug: Boolean = false\n</code></pre>"},{"location":"references/swiftPackageConfig/#packagedependencyprefix","title":"packageDependencyPrefix","text":"<pre><code>/**\n * Represents a prefix used for resolving conflicts or distinguishing between multiple\n * package dependencies within a Kotlin Multiplatform project.\n * This variable can be utilized to customize or uniquely identify package names or references when required.\n *\n * It is nullable and, when set, the prefix will be applied to all dependencies.\n */\npublic var packageDependencyPrefix: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#linkeropts","title":"linkerOpts","text":"<pre><code>/**\n *  Add custom linker flag when exporting the product to kotlin\n */\npublic var linkerOpts: List&lt;String&gt; = emptyList()\n</code></pre>"},{"location":"references/swiftPackageConfig/#compileropts","title":"compilerOpts","text":"<pre><code>/**\n *  Add custom compiler flag when exporting the product to kotlin\n */\npublic var compilerOpts: List&lt;String&gt; = emptyList()\n</code></pre>"},{"location":"references/swiftPackageConfig/#dependency","title":"dependency","text":"<pre><code>/**\n * Adds one or more Swift dependencies to the dependencies list.\n *\n * @param dependency A variable number of `SwiftDependency` instances to be added.\n * This can include local or remote dependencies in the form of\n * Swift packages or binary `xcframework` bundles.\n * It supports different dependency models such as local, versioned\n * remote, branch-based remote, or commit-based remote dependencies.\n */\npublic fun dependency(vararg dependency: SwiftDependency)\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedcachepath","title":"sharedCachePath","text":"<pre><code>/**\n * Represents the file path to the shared cache directory used by the package.\n * This path is utilized for caching purposes to optimize dependency management,\n * reducing redundant network calls or disk operations during the build process.\n * The cache directory can store downloaded Swift package artifacts or other\n * reusable build-related data.\n *\n * If set to `null`, the default cache location will be used, determined\n * by the underlying build tool configuration or environment settings.\n */\npublic var sharedCachePath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedconfigpath","title":"sharedConfigPath","text":"<pre><code>/**\n * Represents the file path to the shared configuration directory.\n *\n * It is optional and can be set to null if no such shared directory is required or use the default one.\n *\n */\npublic var sharedConfigPath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedsecuritypath","title":"sharedSecurityPath","text":"<pre><code>/**\n * Specifies the shared directory path for security-related resources or configurations.\n *\n * It is optional and can be set to null if no such shared directory is required or use the default one.\n */\npublic var sharedSecurityPath: String? = null\n</code></pre>"}]}